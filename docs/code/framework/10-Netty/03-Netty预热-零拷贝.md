**零拷贝**是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种`I/O`操作优化技术。



## 传统的 IO 流程

传统的IO流程，包括read和write的过程。

- `read`：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区
- `write`：先把数据写入到socket缓冲区，最后写入网卡设备。

**流程如下：**



- 用户应用进程调用read函数，向操作系统发起IO调用，**上下文从用户态转为内核态（切换1）**
- DMA控制器把数据从磁盘中，读取到内核缓冲区。
- CPU把内核缓冲区数据，拷贝到用户应用缓冲区，**上下文从内核态转为用户态（切换2）**，read函数返回
- 用户应用进程通过write函数，发起IO调用，**上下文从用户态转为内核态（切换3）**
- CPU将用户缓冲区中的数据，拷贝到socket缓冲区
- DMA控制器把数据从socket缓冲区，拷贝到网卡设备，**上下文从内核态切换回用户态（切换4）**，write函数返回

从流程图可以看出，**传统IO的读写流程**，包括了4次上下文切换（4次用户态和内核态的切换），4次数据拷贝（**两次CPU拷贝以及两次的DMA拷贝**)，什么是DMA拷贝呢？我们一起来回顾下，零拷贝涉及的**操作系统知识点**哈。

**DMA控制器**

> https://juejin.cn/post/7221862036534935612

- CPU拷贝：CPU拷贝是指数据从一个内存区域拷贝到另一个内存区域时，使用CPU执行指令完成的拷贝过程。CPU从源地址读取数据，再将数据写入目标地址，这个过程需要CPU花费大量的时间和计算资源。因此，CPU拷贝在数据量较小的情况下表现良好，但在数据量较大的情况下会导致CPU负载过高，影响系统的性能。
- DMA拷贝：DMA拷贝是指数据从一个内存区域拷贝到另一个内存区域时，使用DMA控制器完成的拷贝过程。DMA控制器是一种`硬件设备`，可以独立于CPU进行数据传输，可以在不占用CPU资源的情况下完成数据拷贝。具体来说，CPU将数据传输的任务交给DMA控制器，然后DMA控制器直接从源地址读取数据，再将数据写入目标地址，整个过程不需要CPU的干预，因此可以大大提高数据传输的效率。

**拷贝的时机如下**

CPU拷贝：数据从发送进程的用户空间拷贝到内核缓冲区时，需要使用CPU执行指令完成拷贝过程。

DMA拷贝：数据从内核缓冲区拷贝到接收进程的用户空间时，可以使用DMA控制器完成拷贝过程，避免了CPU的干预。

## 相关知识点

### 用户态和内核态

操作系统为每个进程都分配了内存空间，一部分是用户空间，一部分是内核空间。**内核空间是操作系统内核访问的区域，主要提供进程调度、内存分配、连接硬件资源等功能，是受保护的内存空间。**

**用户空间是用户应用程序访问的内存区域。** 提供给各个程序进程的空间，它不具有访问内核空间资源的权限，如果应用程序需要使用到内核空间的资源，则需要通过系统调用来完成。进程从用户空间切换到内核空间，完成相关操作后，再从内核空间切换回用户空间。

### 上下文切换

CPU 寄存器，是CPU内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此叫做CPU上下文。

把前一个任务的CPU上下文（也就是CPU寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

一般我们说的**上下文切换**，就是指内核（操作系统的核心）在CPU上对进程或者线程进行切换。进程从用户态到内核态的转变，需要通过**系统调用**来完成。系统调用的过程，会发生**CPU上下文的切换**。

> CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20220422104508941.png)



## 零拷贝

零拷贝（Zero Copy）是一种数据传输的方式，可以避免数据复制的开销，从而提高数据传输的效率。在零拷贝中，数据从应用程序的内存空间直接传输到目标应用程序的内存空间，避免了中间缓冲区的使用，从而避免了数据复制的开销。

具体来说，零拷贝的过程可以分为以下步骤：

- 应用程序将数据写入内存缓冲区。

- 应用程序发起系统调用（例如sendfile()或mmap()等），向操作系统内核发起数据传输请求。

- 操作系统内核将源缓冲区所在的内存页表项设置为可访问的共享内存，将该页表项的描述符直接传递给目标应用程序。
  目标应用程序直接从源缓冲区所在的内存页表项读取数据，完成数据传输。

这个过程中，源缓冲区和目标缓冲区都是由应用程序分配的内存块，操作系统内核不需要将数据从源缓冲区复制到内核缓冲区，也不需要将数据从内核缓冲区复制到目标缓冲区。

相反，操作系统内核直接将源缓冲区所在的内存页表项描述符传递给目标应用程序，让目标应用程序直接访问源缓冲区中的数据。这样，可以避免数据复制的开销，从而提高数据传输的效率。

需要注意的是，零拷贝的实现方式和支持程度可能因操作系统和硬件架构的不同而有所不同。在某些情况下，可能需要在应用程序中进行一些特殊的设置或使用特定的API才能实现零拷贝。

**sendfile()和mmap()**

sendfile()系统调用是用于在两个文件描述符之间传输数据的，它可以在不经过用户空间缓冲区的情况下直接将数据从一个文件描述符传输到另一个文件描述符。其原理是通过在内核中开辟一个页缓存，并在页缓存中实现数据的传输。

mmap()系统调用则是将一个文件或其他对象映射到进程的地址空间，让进程可以直接访问该对象的数据，避免了数据复制的开销。

**文件描述符**

在Unix和Linux等操作系统中，文件描述符（File Descriptor）是一种用于访问文件或其他I/O资源的抽象概念。每个打开的文件或其他I/O资源（如套接字、管道等）都会被分配一个唯一的文件描述符，应用程序可以使用该文件描述符来读取或写入数据。

具体来说，文件描述符是一个非负整数，它在应用程序和操作系统内核之间充当了一个中介的角色，用于建立应用程序与I/O资源之间的联系。

文件描述符的数量通常受到操作系统和硬件的限制，因此应用程序需要正确使用文件描述符，避免出现过多的文件描述符使用和泄露等问题。

**Direct Buffer**

Direct Buffer可以直接映射到操作系统内核缓冲区中，避免了数据在JVM内部和操作系统内核之间的多次复制，从而提高了数据传输的效率。

Direct Buffer的原理是通过调用操作系统的本地I/O函数，在JVM内存之外（堆外内存）分配一块内存区域，然后将这个内存区域与Java NIO缓冲区建立映射关系。

Direct Buffer分配的内存区域不是由Java堆管理的，而是由操作系统内核管理的，因此Direct Buffer的生命周期和Java堆对象不同，需要进行显式的管理和释放。当应用程序不再需要使用Direct Buffer时，需要调用Buffer对象的dispose()方法来释放其占用的内存资源，否则可能会导致内存泄漏。

**Kafka零拷贝**

在Kafka中，通过使用Java NIO的FileChannel和ByteBuffer实现零拷贝，具体的实现过程如下：

- 生产者端使用FileChannel将消息写入操作系统的页缓存中，不需要通过内存缓存区拷贝数据。

- Kafka使用mmap将操作系统的页缓存映射到进程的地址空间中，形成内存映射文件（MappedByteBuffer）。

- 生产者端将消息写入内存映射文件，通过缓存区的指针直接将数据写入内存映射文件中，而不需要将数据拷贝到内存缓冲区。

- 当消费者端从Kafka中拉取消息时，Kafka通过FileChannel和ByteBuffer读取内存映射文件中的数据，直接将数据写入Socket缓冲区，而不需要将数据拷贝到内存缓冲区。

通过使用内存映射文件，Kafka实现了零拷贝的消息传输。这种方式避免了数据在内存之间的拷贝，可以显著降低CPU的开销，提高系统的性能和吞吐量。同时，使用内存映射文件也可以使得Kafka支持更大的消息传输，可以处理更高的数据吞吐量。











https://zhuanlan.zhihu.com/p/258513662

https://mp.weixin.qq.com/s/j1KjR5bRQV6oGrU5tsyHgg
