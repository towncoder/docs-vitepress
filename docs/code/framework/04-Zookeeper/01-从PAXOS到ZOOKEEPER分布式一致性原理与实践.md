# 从PAXOS到ZOOKEEPER分布式一致性原理与实践

## 目录

- 分布式架构：特点及问题、分布式事务、CAP和BASE理论
- 一致性协议：2PC、3PC、Paxos算法
- Paxos的实践：Chubby、Hypertable
- ZAB协议：与Paxos的区别和联系
- zk的使用：安装与命令、Java客户端操作
- zk的典型应用场景：应用场景、大型实践
- `Zookeeper技术内幕`：系统模型、序列化协议、客户端、会话、服务端、leader选举、请求处理、数据存储
- zk运维：配置、远程连接与监控、高可用集群、磁盘管理
- 各版本更新记录

## 分布式架构





## 一致性协议(Paxos和ZAB)

### Paxos

#### 拜占廷将军问题

拜占庭帝国有许多支军队，不同军队的将军之间必须制订一个统一的行动计划，从而做出进攻或者撤退的决定，同时，各个将军在地理上都是被分隔开来的，只能依靠军队的通讯员来进行通讯。然而，在所有的通讯员中可能会存在叛徒，这些叛徒可以任意篡改消息，从而达到欺骗将军的目的。

有点类似满江红里的`全军复诵`，在分布式系统中，网络消息我们可以认为是可靠的，通过简单的检验算法也可以保证消息的完整性，即不存在叛徒，那么这种情况下，怎么保证军队间的一致性呢？

#### Paxos议会

在古希腊有一个叫做Paxos的小岛，岛上采用议会的形式来通过法令，议会中的议员通过信使进行消息的传递。

值得注意的是，议员和信使都是兼职的，他们`随时有可能会离开议会厅`，并且信使可能会`重复的传递消息`，也可能一去不复返。因此，议会协议要保证在这种情况下法令仍然能够正确的产生，并且不会出现冲突。

翻译一下，即服务发出的消息可能因为网络原因无法抵达，也可能重试多次，服务本身也随时可能宕机，如何保证服务间的一致性？

> Paxos算法的作者Leslie Lamport（莱斯利·兰伯特）比较固执，不愿意为算法提供数学证明，认为他讲的故事能够让大多数人理解，但是其实算法很难看懂，因此耽误了算法的问世。

#### 算法详解

**问题描述**

从整体上来说，Paxos算法的目标就是要保证最终有一个提案会被选定，当提案被选定后，进程最终也能获取到被选定的提案。

**三种角色**

在 Paxos 算法中有三种角色，分别具有三种不同的行为。但很多时候，一个进程可能同时充当着多种角色。

- Proposer：提案者
- Acceptor：表决者
- Learner：同步者

**提案的选定**

首先最简单的是只有一个Acceptor，那他只需要投票给收到的第一个提案，但是这样Acceptor会有单点问题。

所以Proposer向一个`Acceptor集合`发送提案，同样，集合中的每个Acceptor都可能会批准(Accept)该提案，当有足够多的Acceptor批准这个提案的时候，我们就可以认为该提案被选定了。

那么，什么是足够多呢？只要`保证每个Acceptor最多只能批准一个提案`，当超过半数时，就是足够多。

**推导过程**

1.如果我们希望即使在只有一个提案被提出的情况下，仍然可以选出一个提案，则`一个Acceptor必须批准它收到的第一个提案`。

2.如果每个Acceptor都批准他收到的第一个提案，则有可能没有提案的支持数会超过半数（或者平票）。

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20230517170705207.png)

由此得出`每个Acceptor必须能够批准不止一个提案`，此时陷入矛盾！

此时得出我们有制定一个更细粒度的Acceptor投票的规则，即可以批准不止一个提案，但是也不是什么提案都能批准。

3.















## ZK的使用

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20230111133426389.png)



### Java操作zk

> 三种方式的对比https://www.cnblogs.com/crazymakercircle/p/10225739.html

### 



### 原生Zookeeper







### ZkClient

内部实现了session超时重连、watcher反复注册等功能。







### Cuartor



## ZK的实战应用

