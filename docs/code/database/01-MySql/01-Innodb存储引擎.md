![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20220418113738301.png)



### innodb的数据更新过程

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20220418115432392.png)

### redo log的刷盘策略

https://www.icode9.com/content-2-1314831.html

0：提交时并不刷盘，而是后台批量刷盘

1：提交时就刷盘

2：写入 OS cache （不直接写入磁盘是为了减少io）

### 二阶段提交

https://blog.csdn.net/qq_33591903/article/details/122030252

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20220418142711065.png)

保证崩溃恢复，对提交中断的事务提供补偿。

第一次提交是发出了刷盘的请求，是否落盘不一定。

对于未提交的中断，以bin log 为准，以维护binlog 和redo log的一致性。

### binlog日志的刷盘策略



### binlong的三种模式



### 生产数据库如何配置

一般Java应用系统部署在4核8G的机器上，每秒钟抗下500左右的并发访问量，差不多是比较合适的。

一台机器能抗下每秒多少请求，往往是跟你每个请求处理耗费多长时间是关联的。

数据库才是真正降低性能的罪魁祸首。所以数据库的服务器配置要高于Java应用配置。

一般8核16G的机器部署的MySQL数据库，每秒抗个一两千并发请求是没问题的。

对于16核32G的机器部署的MySQL数据库而言，每秒抗个两三千，甚至三四千的并发请求也都是可以的。

用固态硬盘代替机械硬盘能提高磁盘io 效率。

**关于 磁盘 IO**

耗时 3-5 ms

主要耗时：

- 寻道

- 旋转偏移

- 数据传输

内存 100ns



### 生产环境数据库压测

QPS：英文全称是Query Per Second。meimieo 。 数据库每秒可以处理多少个请求，你大致可以理解为，一次请求就是一条SQL语句，也就是说这个数据库每秒可以处理多少个SQL语句。

TPS：Transaction Per Second。其实就是每秒可处理的事务量，就是说数据库每秒会处理多少次事务提交或者回滚。

**IO 相关**

（1）IOPS：这个指的是机器的随机IO并发处理的能力，比如机器可以达到200 IOPS，意思就是说每秒可以执行200个随机IO读写请求。

（2）吞吐量：这个指的是机器的磁盘存储每秒可以读写多少字节的数据量。决定日志写入的速度。一般来说我们写redo log之类的日志，都是对磁盘文件进行顺序写入的，也就是一行接着一行的写，不会说进行随机的读写，那么一般普通磁盘的顺序写入的吞吐量每秒都可以达到200MB左右。

（3）latency：这个指标说的是往磁盘里写入一条数据的延迟。

**服务器相关**

- CPU负载
- 内存占用率
- 网络负载

### 压测实战

sysbench 配合 linux 命令 top 、 dstat -d 、 dstat -r 、  dstat -n 。

普罗米修斯+grafa 数据库监控

### 如何配置你的Buffer Pool的大小？

默认128m , 配置 服务器内存的 1/16。

[server]

innodb_buffer_pool_size = 2147483648

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20220418172217707.png)

缓存页：默认情况下，磁盘中存放的数据页的大小是16KB，而Buffer Pool中存放的一个一个的数据页，我们通常叫做缓存页，而Buffer Pool中默认情况下，一个缓存页的大小和磁盘上的一个数据页的大小是一一对应起来的，都是16KB。

描述信息：这个数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址以及别的一些杂七杂八的东西。

>  Buffer Pool中的描述数据大概相当于缓存页大小的5%左右，也就是每个描述数据大概是800个字节左右的大小，然后假设你设置的buffer pool大小是128MB，实际上Buffer Pool真正的最终大小会超出一些，可能有个130多MB的样子，因为他里面还要存放每个缓存页的描述数据。

### 从磁盘读取数据页到Buffer Pool的时候，free链表有什么用？

数据库启动 —— 开辟128兆内存的buffer pool —— 划分缓存页和描述信息 —— 随着增删改查，磁盘数据页的信息加载到buff pool 

**怎么知道哪些缓存页是空闲的呢？**

数据库会为Buffer Pool设计一个free链表，他是一个双向链表数据结构，这个free链表里，每个节点就是一个空闲的缓存页的描述数据块的地址，也就是说，只要你一个缓存页是空闲的，那么他的描述数据块就会被放入这个free链表中。

除此之外，这个free链表有一个基础节点，他会引用链表的头节点和尾节点，里面还存储了链表中有多少个描述数据块的节点，也就是有多少个空闲的缓存页。它不属于Buffer Pool，是40字节大小的一个节点，

**怎么知道数据页有没有被缓存？**

缓存页中的数据如何检索？—— 哈希表

用表空间号+数据页号，作为一个key，然后缓存页的地址作为value。

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20220418175242531.png)

### 当我们更新Buffer Pool中的数据时，flush链表有什么用？

存放所有脏页

凡是被修改过的缓存页，都会把他的描述数据块加入到flush链表中去，flush的意思就是这些都是脏页，后续都是要flush刷新到磁盘上去的。

### 缓存页淘汰

缓存页不够用了怎么办？

刷脏

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20220418180601214.png)

**缓存命中率**

现在有两个缓存页，一个缓存页的数据，经常会被修改和查询，比如在100次请求中，有30次都是在查询和修改这个缓存页里的数据。那么此时我们可以说这种情况下，缓存命中率很高。

将命中率低的刷入磁盘 —— LRU链表

引入一个新的LRU链表了，这个所谓的LRU就是Least Recently Used，最近最少使用的意思。

**简单原理**

假设我们从磁盘加载一个数据页到缓存页的时候，就把这个缓存页的描述数据块放到LRU链表头部去，那么只要有数据的缓存页，他都会在LRU里了，而且最近被加载数据的缓存页，都会放到LRU链表的头部

然后假设某个缓存页的描述数据块本来在LRU链表的尾部，后续你只要查询或者修改了这个缓存页的数据，也要把这个缓存页挪动到LRU链表的头部去，也就是说最近被访问过的缓存页，一定在LRU链表的头部，



## InnoDB三大特性

InnoDB存储引擎有三大特性非常令人激动，它们分别是**插入缓冲、两次写和自适应哈希**。

本篇文章先介绍第一个特性 - 插入缓冲（insert buffer）





## 索引

B+树相比B树有以下优化：

1. 更短的树高度：在B+树中，非叶子节点只存储子节点的索引信息，而不像B树那样存储子节点的全部信息，这样可以让一个非叶子节点存储更多的索引信息，减少节点数量，使得树更加扁平化，树的高度更加短，减少了IO操作。

2. 更高的查询性能：由于所有的数据都存储在叶子节点中，所以查询的时候只需要从根节点出发，沿着非叶子节点到达对应叶子节点，再从叶子节点中查找数据，这样只需要一次磁盘IO操作，比B树更快。

3. 更少的内存占用：由于B+树只需要存储叶子节点的指针，而B树需要存储所有节点的指针信息，所以B+树对内存的占用更少。

4. 更好的范围查询性能：由于数据完全存储在叶子节点中，而且叶子节点之间是有序的，所以B+树比B树更适合范围查询。范围查询只需要在叶子节点中查找数据，不需要遍历非叶子节点，可以通过指针遍历叶子节点实现，效率更高。









