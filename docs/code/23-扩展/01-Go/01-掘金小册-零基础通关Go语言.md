![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/20230612105125.webp)

# 准备篇

## 环境搭建

### 开发环境

和 Java 一样，先安装 SDK 和配置环境变量，先到[官网下载](https://go.dev/dl/)安装包，选择对应的操作系统，目前最新的稳定版本是 `1.20.5`，历史版本往下滑就可以看到，请选择后缀为 `.pkg` 进行下载，不要下载源码包，因为我们暂时还不需要编译源码。

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/20230612110506.png)

打开安装包，和安装其他软件一样，一直`下一步`就好。

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/20230612114349.png)

 安装成功后默认目录是：`/usr/local/go` ，以此来配置环境变量

```shell
vim ~/.bash_profile

export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
export GOPATH=$HOME/go
export GOBIN=$GOPATH/bin

# 刷新下配置文件 
source ~/.bash_profile
```

查看版本来验证是否安装成功

```shell
go version
# go version go1.20.5 darwin/arm64
go env # 查看 Go SDK 环境变量状态
# GOPATH="/Users/libiao/go"
# GOROOT="/usr/local/go"
```

> 使用 HomeBrew 安装也是可以的

### 开发工具

这里选择和 Idea 一个家族的 Goland ，不使用 VScode 。

官网下载安装即可，建议下最新版的，性能会好一些，至于破解，[看这里](https://www.exception.site/)

> GOPATH & GOROOT & GOBIN
>
> - GOROOT 是我们在安装时设置的环境变量，表示 Go 语言的安装目录
> - GOPATH 可以理解为工作空间，存放源代码、测试文件、库静态文件、可执行文件的目录，我觉得像 maven 的仓库地址，需要在 GoLand 中设置好才可以运行，默认为 `/Users/libiao/go`，不能和 GOROOT 相同
> - GOBIN 表示程序编译后二进制命令的安装目录，一般设置为 `GOPATH/bin`

一个 `Hello World` 程序

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/20230612114245.png)

## 代码结构&规范

### 代码结构

```go
package main
import "fmt"

/**
 * Hello World 程序
 */
func main() {
	//打印
	fmt.Println("Hello World!")
}
```

可以看到关于 `package、 import、main`，和 Java 是没有区别的，注释也是和 Java 一样。

### 命名规范

- 源码文件名英文单词全部小写，每个单词之间使用下划线分割。如：`hello_world.go`
- 包名使用尽量简短的英文单词，全部小写，名称不要与Go内置标准库相同。
- 变量名整体遵循驼峰式命名法。public 变量大驼峰，private 变量小驼峰。
- 常量名英文单词全部大写，每个单词之间使用下划线分割。
- 接口名同变量名规范，通常以“er”结尾。如 `type DownloadListener interface`。

## 命令行工具

> 往后放

那 Go 有没有类似 `javac` 这样的命令呢，也是有的，如下：

- `go build` ：编译 Go 源码，并生成可执行的文件，自 1.9 版本开始支持并发编译，所以速度是非常快的。如果使用了第三方的包，这些包会被一同编译。

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/20230612124841.png)

- `go clean` ：清理当前目录内的所有编译生成的文件。
- `go run` ： 直接运行 go 源码，不在当前目录下生成任何可执行的文件。
- `gofmt` ：代码格式化
- `go install` ：和 go build 类似
- `go get` ：获取源码包



# 基础语法篇

## 变量、常量、数据类型

### 基本数据类型

- 整数int系列
- 浮点数float系列
- 复数complex系列）
- 布尔型（bool）
- 字符串型(string)

> 除了基本数据类型之外，还有接口类型和复合类型（可以简单地理解为基本数据的“组合体”，如数组、切片、结构体等）。

### 语法

```go
	var name1 = "name1"
	var name2 = "name2"
	name3 := "name3"
	number := 100
	var name4 = name1
	var (
		text          = "text"
		price float32 = 1.2
	)

	const (
		PI     float64 = 3.14
		WIDTH          = 5
		HEIGHT         = 10
	)
```

## 指针和运算符

### 指针

```go
func main() {
	// exampleNumberA变量（整数型变量）声明和赋值
	var exampleNumberA int = 10
	// 获取exampleNumberA的地址，并赋值给exampleNumberAPtr变量（exampleNumberAPtr的类型是指针类型）
	exampleNumberAPtr := &exampleNumberA
	// 输出exampleNumberAPtr变量的值（将输出内存地址）
	fmt.Println(exampleNumberAPtr)
	// 获取exampleNumberAPtr（指针变量）表示的实际数据值，并赋值给exampleNumberAPtrValue变量（整数型变量）
	exampleNumberAPtrValue := *exampleNumberAPtr
	// 输出exampleNumberAPtrValue变量（整数型变量）的值
	fmt.Println(exampleNumberAPtrValue)

	// 使用new()函数创建名为exampleNumberAPtr指针类型变量，表示int64型值
	exampleNewNumberAPtr := new(int64)
	// 修改exampleNumberAPtr表示的实际数据值
	*exampleNewNumberAPtr = 100
	// 获取exampleNumberAPtr表示的实际数据值
	fmt.Println(*exampleNewNumberAPtr)
}

// 0x1400001c0c8
// 10
// 100
```

### 运算符

> 算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符与 Java 相同
>
> 指针运算符即是刚说过的 `&`  和 ` *`

### 类型转换

> - 只能同类型转换
> - 高精度转为低精度会有精度丢失问题

```go
//声明float32型变量exampleFloat32并赋值
var exampleFloat32 float32 = 150.25
//将exampleFloat32转换为float64类型，并将结果赋值给exampleFloat64
exampleFloat64 := float64(exampleFloat32)
//输出exampleFloat64的类型和值
fmt.Println(reflect.TypeOf(exampleFloat64), exampleFloat64)
//将exampleFloat32转换为int32类型，exampleInt32
exampleInt32 := int32(exampleFloat32)
//输出exampleInt32的类型和值
fmt.Println(reflect.TypeOf(exampleInt32), exampleInt32)
```

## 分支结构

### 循环

相比于 Java ，省去了括号和更方便的变量声明赋值

```go
for init; condition; post {
    //循环体代码块
}
// init 是初始化语句；condition 是关系或逻辑表达式，值为 false 时则会停止循环；post 是每次循环结束后执行的语句；
```

### 分支

同样省去了括号

```go
if condition1 {
    //条件condition1成立时要执行的语句
}else if condition2 {
    //条件condition2成立时要执行的语句
}else if condition3 {
    //条件condition3成立时要执行的语句
}else{
    //以上三种条件都不成立时要执行的语句
}
```

### 流程控制

```go
func main() {
	for i := 0; i < 10; i++ {
		if i == 3 {
			continue
		}
		fmt.Println(i)
		if i == 4 {
			break
		}
	}
}

// 0
// 1
// 2
// 4
```

## 容器

### 数组

数组中的元素不限制值的类型，但要求所有元素均为相同的类型。

```go
func main() {
	var arr [4]int
	for i := 0; i < len(arr); i++ {
		arr[i] = i
	}
	fmt.Println(arr[1])
}
```

### 切片

专门存放不定元素个数的数据结构——切片。（类似 Java 的List）

同样元素不限制值的类型，但要求所有元素均为相同的类型。

在语法上和数组的区别就是声明的时候不用定义长度。

元素有序可重复。

```go
func main() {
	var slice []int
	slice = append(slice, 4)
	slice = append(slice, 4, 6, 7)
	for i := 0; i < len(slice); i++ {
		fmt.Print(slice[i], " ")
	}
}

// 4 4 6 7 
```

### 集合

集合可以看作是一类特殊的切片，只不过集合的元素都是由若干“键-值对”数据构成的。

像是 python 中的集合（字典），与 Java 中的 Map 集合是一个概念。

和数组、切片类似，集合中的键和值均不限制数据类型，且键和值可分别使用不同的类型。但要求所有键均为相同的类型，所有值均为相同类型。

其赋值依然延续集合的方式，只不过把索引换成 key 的值，这里与 Java 有所不同。

若对一个已经存在数据的“键”再次赋值，原有的数据将被覆盖，即 key 不重复，value 可重复。

```go
func main() {
	var info = make(map[int]string)
	info[1] = "zs"
	info[2] = "ls"
	info[2] = "lw"
	info[3] = "zs"
	fmt.Println(info)
	infoItem := info[2]
	fmt.Println(infoItem)
}

// map[1:zs 2:lw 3:zs]
// lw
```

### 操作容器

除了for循环外，Go 语言还提供了 `range` 关键字，有点像 Java 中的增强 for 循环。

```go
for index, value := range variable {
    // 循环体
}
```

演示遍历上面案例中的集合

```go
for k, v := range info {
	fmt.Println(k, "-", v)
}

// 1 - zs
// 2 - lw
// 3 - zs
```

## 函数

### 定义和调用

```go
func function_name([params_list])([return_values_list]){
    // 函数体
}
// function_name是函数名；params_list表示参数列表；return_values_list表示函数的返回值列表；
```

```go
func main() {
	name := "m1"
	fmt.Println(&name)
	fmt.Println(m1(name))
	fmt.Println(name)
	fmt.Println("==============")
	fmt.Println(m2(&name))
	fmt.Println(name)
}

func m1(param string) string {
	param += "pp"
	fmt.Println(&param)
	return param
}

func m2(param *string) string {
	*param += "pp"
	fmt.Println(param)
	return *param
}

// 0x14000096230
// 0x14000096240
// m1pp
// m1
// ==============
// 0x14000116230
// m1pp
// m1pp
```

- 直接传递一个变量名到另一个函数中，属于值传递。按照Go代码的执行策略，发生值传递时，将在另一个函数中自动生成一个值的副本。
- 与值传递相对的便是引用传递，这种方式在函数间传递的是指针，而指针恰恰是内存地址。这样的传值，无论发生在多少个函数之间，改变将始终作用于相同地址的数据上。

### 延迟调用

```go
defer
// “defer”的作用是让整句代码延迟执行，且多个defer存在时，它们的顺序是反向的。
```

演示案例

```go
defer fmt.Println("before")
defer fmt.Println("after")
fmt.Println("==end")

// ==end
// after
// before
```

### 匿名函数

匿名函数是实现回调的核心技能。

```go
func ([params_list])([return_values_list]){
    // 函数体
}
```

匿名函数可以直接在定义时调用，也可以通过变量调用

```go
func main() {
	func(text string) {
		fmt.Println(text)
	}("定义时就调用")

	fun := func(param string) {
		fmt.Println(param)
	}
	fun("invoke")
}

// 定义时就调用
// invoke
```

接下来，做一个模拟网络文件下载，定期查询进度、及时汇报状态进行回调的实战

```go
var progress = 0
var download = true

func main() {
	finishHandler := func() {
		download = false
	}
	go startDownload(finishHandler)
	time.Sleep(500 * time.Millisecond)
	getProgress()
}

func getProgress() {
	for {
		if download {
			fmt.Println("进度：", progress)
		} else {
			break
		}
		time.Sleep(1000 * time.Millisecond)
	}
	fmt.Println("下载完成...")
}

func startDownload(downloadFinish func()) {
	fmt.Println("开始下载...")
	download = true
	for {
		if progress < 100 {
			progress += 20
		} else {
			downloadFinish()
			break
		}
		time.Sleep(500 * time.Millisecond)
	}
}

// 开始下载...
// 进度： 40
// 进度： 60
// 进度： 100
// 下载完成...
```

### 闭包实现工厂模式

闭包在某些编程语言（如Java）中还被称为Lambda表达式。

工厂模式则是编程领域中设计模式的其中一种。

```go
// 游戏角色创建器，传入角色名、职业和性别
func createPlayer(name string, career string, gender string) func() (string, string, string, int, int) {
   var hp = 0
   var mp = 0
   if career == "战士" {
      hp = 150
      mp = 100
   } else if career == "法师" {
      hp = 100
      mp = 200
   }
   // 闭包
   return func() (string, string, string, int, int) {
      return name, career, gender, hp, mp
   }
}
func main() {
   playerA := createPlayer("狂斩天下", "战士", "男")
   nameA, careerA, genderA, hpA, mpA := playerA()
   fmt.Println(genderA, careerA, nameA, hpA, mpA)

   playerB := createPlayer("温玉琳琅", "法师", "女")
   nameB, careerB, genderB, hpB, mpB := playerB()
   fmt.Println(genderB, careerB, nameB, hpB, mpB)
}
```

# 高级语法篇

## 结构体

“万物皆对象”的思想

结构体是由一系列具有相同类型或不同类型的数据构成的数据集合，可以是基本数据类型，也可以是其它结构体。

### 定义和初始化

```go
func main() {
	type People struct {
		name   string
		age    int
		gender string
	}
	people := People{
		name:   "zs",
		age:    12,
		gender: "1",
	}
	fmt.Println(people)
	people.name = "ls"
	fmt.Println(people.name)
}

// {zs 12 1}
// ls
```

在实际开发中，还有一类情况，就是某个结构体的作用域很小，甚至只存在于某个函数内部，或是无需创建太多的该结构体变量等等。对于上述情况，Go语言允许我们使用匿名结构体简化编码，即使用匿名结构体。

```go
cat := struct {
		name  string
		color string
	}{
		name:  "kitty",
		color: "white",
	}
	fmt.Println(cat.color)

// white
```

[扩展](https://juejin.cn/post/7040361996553814023)

### 构造函数

```go
type Animal struct {
	id   int
	name string
	age  int
}

type Dog struct {
	animal Animal
	color  string
}

func newDog(color string) *Dog {
	return &Dog{
		color: color,
		animal: Animal{
			id: 1,
		},
	}
}
func main() {
	var dog = newDog("白色")
	fmt.Println(dog.color)
	fmt.Println(dog.animal.id)
	fmt.Println(dog.animal.age)
}

// 白色
// 1
// 0
```

注意一点：即使不赋值，也不会报 null ，而是返回各个类型的默认值，比如 0、

### 父子继承

从本质上说，Go 语言中继承，是通过结构体的组合来实现的。

## 接口

### 定义和实现

概括地说，接口的作用实际上就是规定了对象的“行动法则”。

```go
type interface_name interface{
    function_name( [params] ) [return_values]
    ...
}

/**
* type关键字表示要自定义类型；interface_name是自定义的接口名；interface表示接口类型；由大括号包裹的部分定义了要被* 实现方法，一个接口中可以同时存在一个或多个方法。function_name是方法名；params是方法所需的参数；return_values是* 方法的返回值。params和return_values可以省略，也可以存在一个或多个。
**/

func (struct_variable struct_name) function_name([params]) [return_values] {
   // 方法实现 
}

/**
* 其中，struct_name_variable和struct_name一起，表示作用的对象。对于本例而言，则是*fileCache类型的变量。紧接着的 * function_name是方法名，params指的是方法所需的参数，return_values指的是方法的返回值。其中，params和
* return_values是可选的，也允许有多个值。
**/
```

```go
func main() {
	//从本地缓存中获取数据
	var imageLoader ImageDownloader
	imageLoader = new(fileCache)
	data := imageLoader.FetchImage("https://www.example.com/a.png")
	fmt.Println(data)
	if data == "" {
		// 当本地缓存中没有数据时，从网络下载
		var imageLoader2 ImageDownloader
		imageLoader2 = new(netFetch)
		data2 := imageLoader2.FetchImage("https://www.example.com/a.png")
		fmt.Println(data2)
	}
}

// ImageDownloader 图片加载接口
type ImageDownloader interface {
	// FetchImage 获取图片，需要传入图片地址，方法返回图片数据
	FetchImage(url string) string
}

// FetchImage接口实现
type fileCache struct {
}

func (f *fileCache) FetchImage(url string) string {
	//return "从本地缓存中获取图片：" + url
	return ""
}

type netFetch struct {
}

func (n *netFetch) FetchImage(url string) string {
	return "从网络下载图片：" + url
}
```



### 空接口

空接口就是 Java 中泛型的概念。

空接口内部无需填写任何方法，空接口能接纳所有类型的数据，因此可以将任何类型的数据赋值给它的变量。

```go
interface{}
```

```go
// 泛型
func dataOutput(data interface{}) {
	fmt.Println(data)
}

func main() {
	dataOutput("Hello")
	dataOutput(123)
	dataOutput(true)
}
// Hello
// 123
// true
```

### 接口运用

接口和类型一样，是可以嵌套使用的，即组合。

从空接口取值，要使用类型断言。

```go
func dataOutput(data interface{}) {
   fmt.Println(data)
   stringValue := data.(string)
   // var stringValue string = data  Cannot use 'data' (type interface{}) as the type string
   fmt.Println(stringValue)
}
```

在Go语言中，有两种数据是无法比较的，它们是：Map和Slice，强行比较会引发如上宕机错误。

```go
func main() {
   var a interface{} = []int{1, 2, 3, 4, 5}
   var b interface{} = []int{1, 2, 3, 4, 5}
   fmt.Println(a == b)
}
// 正确写法，使用数组：var b interface{} = [5]int{1, 2, 3, 4, 5}
```

在Go语言中，nil是一个特殊的值，它只能赋值给指针类型和接口类型。

## 包

### Go 程序是怎么跑起来的？

Go语言通过包来组织源码，拥有相同包名的Go源码属于同一个包。反过来，一个包内通常会包含一个或多个Go源码文件。

```go
package main
```

Go语言有一个强制性要求，就是源码文件的第一行有效代码必须声明自己所在的包。

main 包是一个比较特殊的包。一个Go程序必须有且只能有一个 main 包。

`main()`函数是程序的入口函数，它位于 main 包中，实际上，Go程序还有一个init()函数，被称为“初始化”函数。

```go
import "fmt"

func init() {
	fmt.Println("Hello")
}
func main() {
	fmt.Println("World")
}

// Hello
// World
```

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/20230625110741.png)

### 导包

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/20230625111456.png)

```go
import (
	"go-pass/juejin.cn/weather"
)
func main() {
	weather.CurrentWeather("beijing")
}
```

















## 并发

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/20230625114951.png)



## 反射





# 框架篇













