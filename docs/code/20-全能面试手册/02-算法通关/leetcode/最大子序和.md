【leetcode刷题】7.最大子序列——Java版

>看到这题难度为简单，我陷入了沉思! 思考了30分钟我一行代码没写出来，我又陷入了沉思
>
>——leetcode此题热评

## 前言

>今天看到群里一个兄弟校招进了阿里。
>
>说实话，羡慕之极又感叹时光易逝。
>
>不过只要你想努力，什么时候都不算晚。
>
>看题吧!

## Question

<font color=green>难度：简单</font>

>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
>示例 1：
>
>```
>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
>输出：6
>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
>```
>
>
>示例 2：
>
>```
>输入：nums = [1]
>输出：1
>```
>
>
>示例 3：
>
>```
>输入：nums = [0]
>输出：0
>```
>
>
>示例 4：
>
>```
>输入：nums = [-1]
>输出：-1
>```
>
>
>示例 5：
>
>```
>输入：nums = [-100000]
>输出：-100000
>```
>
>提示：
>
>```
>1 <= nums.length <= 3 * 104
>-105 <= nums[i] <= 105
>```

## Solution

>此题可以用`贪心算法`或者`动态规划`
>
>但仔细分析其实只是同一个的方向的两种思考方式

- 明确一个问题，如果之前的和大于零，对结果有增益，小于零，无增益，舍去。
- `贪心算法`：若当前指针所指元素之前的和小于0，则丢弃。
- `动态规划`：若前一个元素大于0，则将其加到当前元素上。
- 两种一个是`if`，一个是`else`。

## Code

>所有`leetcode`代码已同步至[github](https://github.com/lbsys/leetcode/tree/master/src/leetcode/editor/cn)
>
>欢迎`star`

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum=nums[0];
        int cursum=0;
        for (int i = 0; i < nums.length; i++) {
            if (cursum > 0) {
                cursum += nums[i];
            } else {
                cursum = nums[i];
            }
            maxSum = Math.max(maxSum, cursum);
        }
        return maxSum;
    }
}
```

## Result

> 复杂度分析
>
> - 时间复杂度：O(N) 

![image-20210718205939425](D:\Download\typoraPic\image-20210718205939425.png)



![image-20210718210229793](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20210718210229793.png)