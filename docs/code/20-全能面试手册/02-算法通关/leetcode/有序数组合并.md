【leetcode刷题】4.有序数组合并——Java版（美团一面）

>把数组2替换掉数组1里的0，然后.sort()排序。我真是魔鬼（dog脸）
>
>——leetcode此题热评

## 前言

>这是一条美团一面遇到的题目，属于简单级别。
>
>仔细思考和昨天的`滑动窗口`有异曲同工之妙！

## Question

<font color=green>难度：简单</font>

>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
>
>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
>
> 
>
>示例 1：
>
>```
>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
>输出：[1,2,2,3,5,6]
>```
>
>示例 2：
>
>```
>输入：nums1 = [1], m = 1, nums2 = [], n = 0
>输出：[1]
>```
>
>提示：
>
>```
>nums1.length == m + n
>nums2.length == n
>0 <= m, n <= 200
>1 <= m + n <= 200
>-109 <= nums1[i], nums2[i] <= 109
>```

## Solution

>- 定义两个指针分别指向`nums1`和`nums2`的元素。
>- 定义一个新数组的指针
>- **注意：**`nums1.length == m + n `，这个信息告诉我们不需新建数组，`原地修改`即可。
>- 为了不破坏原有数组，从后向前遍历，边比较边修改。

## Code

```java
/**
 * @author yitiaoIT
 */
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int indexM1=m-1;
        int indexN2=n-1;
        int index=m+n-1;
        while (indexN2>=0||indexM1>=0){
            if (indexM1<=-1){
                nums1[index--]=nums2[indexN2--];
            }else if(indexN2<=-1){
                nums1[index--]=nums1[indexM1--];
            }else{
                nums1[index--]=nums1[indexM1]>nums2[indexN2]?nums1[indexM1--]:nums2[indexN2--];
            }

        }
    }
}
```

## Result

> 复杂度分析
>
> - 时间复杂度：O(max(m,n)) 

![image-20210715214638696](C:\Users\libia\AppData\Roaming\Typora\typora-user-images\image-20210715214638696.png)

-----

我是**一条**，一个在互联网摸爬滚打的程序员。

**道阻且长，行则将至**。大家的 **【点赞，收藏，关注】** 就是一条创作的最大动力，我们下期见！

注：关于本篇博客有任何问题和建议，欢迎大家留言！