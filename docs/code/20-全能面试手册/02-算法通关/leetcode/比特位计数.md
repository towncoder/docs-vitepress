【leetcode刷题】13.比特位计数——Java&python版

<font color=red>⭐欢迎订阅[《leetcode》](https://blog.csdn.net/skylibiao/category_10867560.html)专栏，每日一题，每天进步⭐</font>

>这道题有两种位运算思路，都是利用数组前面已经算好的数来计算当前数的1的个数
>
>——leetcode此题热评

## 前言

>哈喽，大家好，我是一条。
>
><font color=orange>糊涂算法，难得糊涂</font>
>
>`leetcode`热度榜前`100`简单题中的数组部分马上刷完，接下来做链表相关

## Question

#### [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

<font color=green>难度：简单</font>

>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
>
>示例 1:
>
>```
>输入: 2
>输出: [0,1,1]
>```
>
>示例 2:
>
>```
>输入: 5
>输出: [0,1,1,2,1,2]
>```
>
>进阶:
>
>```
>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
>要求算法的空间复杂度为O(n)。
>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。
>```

## Solution

>题目要求只扫描一次，所以我们思考能否用`已知`求`未知`，也可以理解成把`复杂问题`分解成`简单问题`，也就是动态规划得思想
>
>参考[爬楼梯](https://blog.csdn.net/skylibiao/article/details/118945345)

对于一个二进制数来说，如果它的最低位为`1`(奇数）,则它与` n/2 `（他前面得偶数）的 `1 `得个数相差`1`。

 如果它的最低位为 `0`(偶数)，则它与 n/2 的 1 个数相同，这样就可以用前面的推出后面的。

0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。

## Code

>所有`leetcode`代码已同步至[github](https://github.com/lbsys/leetcode/tree/master/src/leetcode/editor/cn)
>
>欢迎`star`

```java
/**
 * @author yitiaoIT
 */
class Solution {
    public int[] countBits(int n) {
        int count1[] = new int[n+1];
        count1[0]=0;
        for (int i = 0; i <= n; i++) {
           if(i%2==0) {
               count1[i]=count1[i/2];
           }
           else {
               count1[i]=count1[i-1]+1;
           }
        }
        return count1;
    }
}
```



## Result

> 复杂度分析
>
> - 时间复杂度：O(N) 

![image-20210725134952216](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20210725134952216.png)

## End

>更多算法题欢迎关注专栏[《leetcode》](https://blog.csdn.net/skylibiao/category_10867560.html)

![image-20210724205358625](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20210724205358625.png)

![image-20210725141421386](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20210725141421386.png)