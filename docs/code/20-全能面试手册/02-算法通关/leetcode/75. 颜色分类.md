【算法通关】75. 颜色分类——双指针

>0，1，2 排序。一次遍历，如果是0，则移动到表头，如果是2，则移动到表尾，不用考虑1。0和2处理完，1还会有错吗？
>
>——leetcode此题热评

## 前言

大家好，我是一条，欢迎来到我的算法频道。

**只做有趣的算法题，只为面试写算法**。

## Question

#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

<font color=orange>难度：中等</font>

>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
>
>必须在不使用库的sort函数的情况下解决这个问题。
>
> 
>
>示例 1：
>
>输入：nums = [2,0,2,1,1,0]
>输出：[0,0,1,1,2,2]
>示例 2：
>
>输入：nums = [2,0,1]
>输出：[0,1,2]
>
>
>提示：
>
>n == nums.length
>1 <= n <= 300
>nums[i] 为 0、1 或 2
>
>
>进阶：
>
>你可以不使用代码库中的排序函数来解决这道题吗？
>你能想出一个仅使用常数空间的一趟扫描算法吗？

## Solution

> 一个小tips：
>
> 循环中的++i和i++结果是一样的，但是性能不一样，在大量数据的时候++i的性能要比i++的性能好。
>
> 原因： i++由于是在使用当前值之后再+1，所以需要一个临时的变量来转存。 而++i则是在直接+1，省去了对内存的操作的环节，相对而言能够提高性能。
>
> 据测试编译器优化后相差时间并不大，作为了解即可。

翻译一下题目：

经典的荷兰国旗问题，翻译完就是，一个只包含0、1、2的数组，请按升序排序。

可以用计数排序，但严格来说扫描了两次，最优解使用双指针，比较并交换。

## Code

```java
/**
 * @author 一条coding
 */
class Solution {
    public void sortColors(int[] nums) {
        int n = nums.length;
        int p0 = 0, p1 = 0;
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 1) {
                int temp = nums[i];
                nums[i] = nums[p1];
                nums[p1] = temp;
                ++p1;
            } else if (nums[i] == 0) {
                int temp = nums[i];
                nums[i] = nums[p0];
                nums[p0] = temp;
                if (p0 < p1) {
                    temp = nums[i];
                    nums[i] = nums[p1];
                    nums[p1] = temp;
                }
                ++p0;
                ++p1;
            }
        }
    }
}
```

## 最后

点赞，点赞，还TMD是点赞！

