【leetcode刷题】27.二叉树的直径——Java版

<font color=red>⭐欢迎订阅[《leetcode》](https://blog.csdn.net/skylibiao/category_10867560.html)专栏，每日一题，每天进步⭐</font>

>可以将二叉树的直径转换为：二叉树的每个节点的左右子树的高度和的最大值。
>
>——leetcode此题热评

## 前言

哈喽，大家好，我是一条。

<font color=orange>糊涂算法，难得糊涂</font>

## Question

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

<font color=green>难度：简单</font>

>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
>
> 
>
>示例 :
>![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20210810185032024.png)
>
>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
>
> 
>
>注意：两结点之间的路径长度是以它们之间边的数目表示。
>

## Solution

>还是递归+深度优先搜索
>

我们定义一个递归函数 `depth(node)` ，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 `L`和 `R`，则该节点为根的子树的深度即为`max(L,R)+1`

递归搜索每个节点返回最大值即可。


## Code

>所有`leetcode`代码已同步至[github](https://github.com/lbsys)
>
>欢迎`star`

```java
/**
 * @author yitiaoIT
 */
class Solution {
    int maxd=0;
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return maxd;
    }
    public int depth(TreeNode node){
        if(node==null){
            return 0;
        }
        int Left = depth(node.left);
        int Right = depth(node.right);
        maxd=Math.max(Left+Right,maxd);//将每个节点最大直径(左子树深度+右子树深度)当前最大值比较并取大者
        return Math.max(Left,Right)+1;//返回节点深度
    }
}
```

## Result

> 复杂度分析
>
> - 时间复杂度：O(N) 


![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20210811094203584.png)

## 🌈寻宝

>⭐今天是坚持刷题更文的第**27**/100天
>
>⭐各位的<font color=orange>点赞、关注、收藏、评论、订阅</font>就是一条创作的最大动力
>
>⭐更多算法题欢迎关注专栏[《leetcode》](https://blog.csdn.net/skylibiao/category_10867560.html)

为了回馈各位粉丝，礼尚往来，给大家准备了一条多年积累下来的优质资源，包括<font color=orange> 学习视频、面试资料、珍藏电子书等</font>

大家可以先自己找一下获取方式，寻宝游戏现在开始。

如果实在找不到<font color=red>可以评论区留言或私信我领取，不过一定要先关注哦！不然无法发私信！</font>

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20210728234254025.png)