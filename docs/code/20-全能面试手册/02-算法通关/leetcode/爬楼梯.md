【leetcode刷题】8.爬楼梯——Java版

>以为真easy的我天真地用了递归，然后超时了。。。敲
>
>——leetcode此题热评

## 前言

>哈喽，大家好，我是一条。
>
>`糊涂算法，难得糊涂。`
>
>今天我们爬楼梯!

## Question

<font color=green>难度：简单</font>

>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
>
>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
>注意：给定 n 是一个正整数。
>
>示例 1：
>
>```
>输入： 2
>输出： 2
>解释： 有两种方法可以爬到楼顶。
>
>1.  1 阶 + 1 阶
>2.  2 阶
>```
>
>
>示例 2：
>
>```
>输入： 3
>输出： 3
>解释： 有三种方法可以爬到楼顶。
>
>1.  1 阶 + 1 阶 + 1 阶
>2.  1 阶 + 2 阶
>3.  2 阶 + 1 阶
>```

## Solution

>通过对规律的总结，不难发现是`斐波那契数列`，可直接利用其`通项公式`
>
>但这样似乎失去了算法的乐趣，所以使用`动态规划`

- 第n个台阶只能从第n-1或者n-2个上来。
- 到第n-1个台阶的走法 + 第n-2个台阶的走法 = 到第n个台阶的走法。
- 已经知道了第1个和第2个台阶的走法，一路加上去。



![img](D:\Download\typoraPic\6a79d456d05de649023252cae49590da.svg)

## Code

>所有`leetcode`代码已同步至[github](https://github.com/lbsys/leetcode/tree/master/src/leetcode/editor/cn)
>
>欢迎`star`

```java
class Solution {
    public int climbStairs(int n) {
        int climbMethods[]=new int[n+1];
        climbMethods[0]=1;
        climbMethods[1]=1;
        for (int i = 2; i <climbMethods.length; i++) {
            climbMethods[i]=climbMethods[i-1]+climbMethods[i-2];
        }
        return climbMethods[n];
    }
}
```

## Result

> 复杂度分析
>
> - 时间复杂度：O(N) ，

![image-20210719153849990](D:\Download\typoraPic\image-20210719153849990.png)

![image-20210719154739532](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20210719154739532.png)