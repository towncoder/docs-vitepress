【leetcode刷题】6.合并有序链表——Java版

>先提前剧透一下，大家要好好做这一题，因为148题会用到这一题...
>
>——leetcode此题热评

## 前言

>xdm,现在是早上`8：24`，窗外下着小雨
>
>我是一条，我在做`leetcode`第`21`题
>
>加油！

## Question

<font color=green>难度：简单</font>

>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
>
>示例 1：
>
>```
>输入：l1 = [1,2,4], l2 = [1,3,4]
>输出：[1,1,2,3,4,4]
>```
>
>
>示例 2：
>
>```
>输入：l1 = [], l2 = []
>输出：[]
>```
>
>示例 3：
>
>```
>输入：l1 = [], l2 = [0]
>输出：[0]
>```
>
>提示：
>
>```
>两个链表的节点数目范围是 [0, 50]
>-100 <= Node.val <= 100
>l1 和 l2 均按 非递减顺序 排列
>```

## Solution

>不知道大家还记得`合并有序数组`吗?
>
>异曲同工
>
>忘记的小伙伴可以先看一下
>
>[传送门1](https://blog.csdn.net/skylibiao/article/details/118855665?spm=1001.2014.3001.5501)
>
>[传送门2](https://mp.weixin.qq.com/s/OxK41O1mJTVL3V994wDyIA)

- 当` l1` 和`l2`  都不是空链表时，判断` l1` 和`l2` 哪一个链表的头节点的值更小，将较小值的节点添加到结果里。

- 当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。
- 将非空链表接在合并链表的后面
- 对于链表操作，一般都需要维护一个当前节点的指针，可以再回看一下[两数相加](https://blog.csdn.net/skylibiao/article/details/114682064)帮助理解

## Code

>所有`leetcode`代码已同步至[github](https://github.com/lbsys/leetcode/tree/master/src/leetcode/editor/cn)
>
>欢迎`star`

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode l3 = new ListNode(-1);
        ListNode cur=l3;
        while (l1!=null&&l2!=null){
            if (l1.val <= l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur=cur.next;
        }
        cur.next = l1 == null ? l2 : l1;
        return l3.next;

    }
}
```



## Result

> 复杂度分析
>
> - 时间复杂度：O(m+n) 

![image-20210718093840159](D:\Download\typoraPic\image-20210718093840159.png)



![image-20210718081349062](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20210718081349062.png)