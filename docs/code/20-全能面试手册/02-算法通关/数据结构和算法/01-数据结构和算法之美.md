> 极客时间 - [数据结构和算法之美](https://b.geekbang.org/member/course/detail/40961)

# 基础篇

## 数组

线性数据结构，用连续的内存空间存储同一类型的数据，支持按下标的随机访问。

**寻址公式**

拿一个长度为 8 的 int 类型的数组`int[] a = new int[10]`来举例。

如下图，计算机给数组 a[10]，分配了一块连续内存空间 1000～1031，其中，内存块的首地址为 base_address = 1000。

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20230131172857583.png)

```
a[i]_address = base_address + i * data_type_size
// data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 
// data_type_size 就为 4 个字节,base_address = 1000
```

根据上面的公式也可以解释为什么数组的下标从 0 开始，如果是1，那每次寻址都会多一步减一操作。

**插入删除优化**

- 插入到指定元素时，如不考虑顺序性，可以直接将第k个元素放到最后
- 删除时可以先标记，等空间不足时再统一删除

**数组下标越界趣事**

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。

根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以会导致代码无限循环。



**数组和集合**

- 业务开发用集合就好，创建 ArrayList 的时候事先指定数据大小，避免扩容时的内存申请和数据搬移。

- 对于底层开发和存储基本数据类型，推荐数组

## 链表

链表与数组的一大区别就是内存空间不连续，这样就可以把很多零碎的内存空间利用起来。如下图：

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20230112113859784.png)

其插入删除的效率非常高，O(1)，而查询的时间表复杂度位O(n)。

**三种结构**

- 单向链表
- 循环链表
- 双向链表：稍微占内存，但能快速的得到前驱节点，提高删除插入查找效率，使用较多（空间换时间）
- 双向循环链表

**如何基于链表实现 LRU 缓存淘汰算法？**

> 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。 
>
> 缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

- 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 
- 如果此数据没有在缓存链表中，又可以分为两种情况： 如果此时缓存未满，则将此结点直接插入到链表的头部； 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。

**基于散列表的LRU优化**

[代码实现](https://blog.csdn.net/qq_44682266/article/details/119303196)



## 栈

一种操作受限的线性表数据结构,先入先出结构，可以基于数组或者链表实现。

```java
// 基于数组实现的顺序栈
public class ArrayStack {
  private String[] items;  // 数组
  private int count;       // 栈中元素个数
  private int n;           //栈的大小

  // 初始化数组，申请一个大小为n的数组空间
  public ArrayStack(int n) {
    this.items = new String[n];
    this.n = n;
    this.count = 0;
  }

  // 入栈操作
  public boolean push(String item) {
    // 数组空间不够了，直接返回false，入栈失败。
    if (count == n) return false;
    // 将item放到下标为count的位置，并且count加一
    items[count] = item;
    ++count;
    return true;
  }
  
  // 出栈操作
  public String pop() {
    // 栈为空，则直接返回null
    if (count == 0) return null;
    // 返回下标为count-1的数组元素，并且栈中元素个数count减一
    String tmp = items[count-1];
    --count;
    return tmp;
  }
}
```



**栈在表达式求值中的应用**

`3+5*8-6`这个表达式的计算过程是怎样的呢？编译器如何先计算乘法？

实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。 

如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20230112151107192.png)

**括号匹配**

我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。

当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，则继续扫描剩下的字符串。

如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。 

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。

**浏览器前进后退**

两个栈，入栈出栈即可实现



## 队列

> 当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？

和栈一样，也是一种操作受限的线性表数据结构。

作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。

```java
// 用数组实现的队列
public class ArrayQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head表示队头下标，tail表示队尾下标
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为capacity的数组
  public ArrayQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }

  // 入队
  public boolean enqueue(String item) {
    // 如果tail == n 表示队列已经满了
    if (tail == n) return false;
    items[tail] = item;
    ++tail;
    return true;
  }

  // 出队
  public String dequeue() {
    // 如果head == tail 表示队列为空
    if (head == tail) return null;
    // 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了
    String ret = items[head];
    ++head;
    return ret;
  }
}
```

**循环队列**



**阻塞队列和并发队列**

阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。如果队列已经满了，那么插入数据的操作就会被阻塞。

并发队列是线程安全的队列，一般使用CAS来保证原子性，参考Disruptor。

> [无锁队列](https://www.cnblogs.com/takumicx/p/9456874.html)

## 二分查找

- 循环退出条件,注意是 low<=high，而不是 low<high
- mid 的取值,实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会大于int的取值范围。改进的方法是将 mid 的计算方式写成 `low+(high-low)/2`。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多。
- low 和 high 的更新,low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。

**非递归实现**

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;

  // 注意是 low<=high，而不是 low
  while (low <= high) {
    int mid = (low + high) / 2;
    if (a[mid] == value) {
      return mid;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  return -1;
}
```

**递归实现**

```java
// 二分查找的递归实现
public int bsearch(int[] a, int n, int val) {
  return bsearchInternally(a, 0, n - 1, val);
}

private int bsearchInternally(int[] a, int low, int high, int value) {
  if (low > high) return -1;

  int mid =  low + ((high - low) >> 1);
  if (a[mid] == value) {
    return mid;
  } else if (a[mid] < value) {
    return bsearchInternally(a, mid+1, high, value);
  } else {
    return bsearchInternally(a, low, mid-1, value);
  }
}
```

**应用场景**

- 只适用于顺序表（数组）结构（满足其随机访问），且数据有序。
- 数据量小没必要，数据量太大如果用数组存储就需要很大的连续内存空间，也不合适。
- 比较操作很耗时的查找建议使用

### 变形问题

**变体一：查找第一个值等于给定值的元素**

有序数据集合中存在重复的数据，我们希望找到第一个值等于给定值的数据，这样之前的二分查找代码还能继续工作吗？

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20230113104338448.png)

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      // 如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 a[mid]的前一个元素 a[mid-1]不等于 value，那也说明 a[mid]就是我们要找的第一个值等于给定值的元素。 如果经过检查之后发现 a[mid]前面的一个元素 a[mid-1]也等于 value，那说明此时的 a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 high=mid-1，因为要找的元素肯定出现在[low, mid-1]之间。
      if ((mid == 0) || (a[mid - 1] != value)) return mid;
      else high = mid - 1;
    }
  }
  return -1;
}

```



**变体二：查找最后一个值等于给定值的元素**

```java
else { 
  if ((mid == n - 1) || (a[mid + 1] != value)) 
    return mid; 
  else low = mid + 1;
}
```

**变体三：查找第一个大于等于给定值的元素**

```java
// 和前面的思路一样
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] >= value) {
      if ((mid == 0) || (a[mid - 1] < value)) return mid;
      else high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return -1;
}
```

**变体四：查找最后一个小于等于给定值的元素**

不赘述

**变体应用**

有如下ip地址和归属地的对应关系：

```
[202.102.133.0, 202.102.133.255]  山东东营市 
[202.102.135.0, 202.102.136.255]  山东烟台 
[202.102.156.34, 202.102.157.255] 山东青岛 
[202.102.48.0, 202.102.48.255] 江苏宿迁 
[202.102.49.15, 202.102.51.251] 江苏泰州 
[202.102.56.0, 202.102.56.255] 江苏连云港
。。。。。。 12 万条
```

假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？

> IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。
>
> 这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。

## 跳表

有单链表演变而来，意在解决单链表查询效率慢的问题，由链表+多级索引组成，将单链表没隔一个结点抽出来做成索引，对索引重复上述操作，直到索引层只剩两个节点。

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20230116104727644.png)

索引层级越高，占用空间越大（不会特别大，因为索引只存储地址，不存储真实数据），查询越快。

整个跳表的高度就是`log2n`，在跳表中查询任意数据的时间复杂度就是 O(logn)，空间复杂度是 O(n)。

**插入和删除**

对于插入和删除，链表天生就是O(1)的时间复杂度，如果要保证有序性，先查询位置，根据多级索引，也不会慢。

**平衡性**

这里有同学可能会有疑问，插入和删除的时候不更新索引吗？

答案一定是要更新的，不然就有`退化成单链表`的风险，类似红黑树是使用旋转节点的方式更新，那跳表是何时更新索引，又是如何更新的呢?

`跳表是通过随机函数来维护前面提到的“平衡性”`,通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20230116110930994.png)

**与红黑树的比较**

- 跳表对于区间查询优于红黑树（redis有序集合使用跳表的原因）
- 跳表相比于红黑树实现较为简单，但由于出现的较晚，很多语言没有现成的数据结构可以使用，需要自己写。

## 哈希表(散列表)

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

其核心思想就是`通过散列函数把元素的键值映射为下标`，再利用数组的下标随机访问。

`散列函数`，我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。

`散列冲突`，简单理解就是不同的key计算出的value值相同的。如何解决呢？

1.开放寻址法 

开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？

先讲一个比较简单的探测方法，线性探测（Linear Probing）：从存储位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

2.链表法

参考HashMap

**如何设计散列函数？**





**哈希算法**

将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法。（同散列算法）

应用：

- 安全加密
- 唯一标识
- 数据校验
- 散列函数
- 负载均衡
- 数据分片
- 分布式存储

## 二叉树







## 红黑树





