## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **186/1000** 。

## 今日题型

动态规划

## [509]斐波那契数

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。



**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```



**解析**

**Code**

```java
class Solution {
        public int fib(int n) {
            if (n == 0) return 0;
            int[] dp = new int[n + 1];
            dp[0] = 0;
            dp[1] = 1;
            for (int i = 2; i <= n; i++) {
                dp[i] = dp[i - 1] + dp[i - 2];
            }
            return dp[n];
        }
    }
```



## [119]杨辉三角 II

给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/1626927345-DZmfxB-PascalTriangleAnimated2.gif)



**示例 1:**

```
输入: rowIndex = 3
输出: [1,3,3,1]
```



**解析**



**Code**

```java
class Solution {
        public List<Integer> getRow(int rowIndex) {
            List<List<Integer>> list = new ArrayList<>();
            List<Integer> rowOne = new ArrayList<>();
            rowOne.add(1);
            List<Integer> rowTwo = new ArrayList<>();
            rowTwo.add(1);
            rowTwo.add(1);
            list.add(rowOne);
            list.add(rowTwo);
            for (int i = 2; i <= rowIndex; i++) {
                List<Integer> row = new ArrayList<>();
                for (int j = 0; j <= i; j++) {
                    if (j == 0) {
                        row.add(j, list.get(i - 1).get(j));
                    } else if (j == i) {
                        row.add(j, list.get(i - 1).get(j - 1));
                    } else {
                        row.add(j, list.get(i - 1).get(j) + list.get(i - 1).get(j - 1));
                    }
                }
                list.add(row);
            }
            return list.get(rowIndex);
        }
    }
```



## [剑指 Offer 42]连续子数组的最大和

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。



**示例1:**

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```



**解析**



**Code**

```java
class Solution {
        public int maxSubArray(int[] nums) {
            // 定义状态（定义子问题）
            //dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。
            int[] dp = new int[nums.length];
            dp[0] = nums[0];
            int ans = dp[0];
            for (int i = 1; i < nums.length; i++) {
                dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
                ans = Math.max(ans, dp[i]);
            }
            return ans;
        }
    }
```

