## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **182/1000** 。

## 今日题型

贪心算法

## [575]分糖果

Alice 有 `n` 枚糖，其中第 `i` 枚糖的类型为 `candyType[i]` 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。

医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 `n / 2` 即可（`n` 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。

给你一个长度为 `n` 的整数数组 `candyType` ，返回： Alice *在仅吃掉 `n / 2` 枚糖的情况下，可以吃到糖的 **最多** 种类数*。



**示例 1：**

```
输入：candyType = [1,1,2,2,3,3]
输出：3
解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。
```

**解析**

哈希表+贪心。用数组优化哈希表提高相率。

**Code**

```java
class Solution {
        public int distributeCandies(int[] candyType) {
//             哈希 + 贪心
//             -105 <= candyType[i] <= 105
//             Map<Integer, Integer> map = new HashMap<>();
//                        for (int j : candyType) {
//                map.put(j, map.getOrDefault(j, 0) + 1);
//            }
            boolean[] map = new boolean[200001];  // 优化哈希表

            int sum = 0;
            for (int j : candyType) {
                if (!map[j + 100000]) {
                    sum++;
                    map[j + 100000] = true;
                }
                if (sum >= candyType.length / 2) {
                    break;
                }
            }
            return sum;
        }
    }
```



## [553]最优除法

给定一组**正整数，**相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -> 2 / 3 / 4 。

但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到**最大的**结果，并且返回相应的字符串格式的表达式。**你的表达式不应该含有冗余的括号。**

**示例：**

```
输入: [1000,100,10,2]
输出: "1000/(100/10/2)"
解释:
1000/(100/10/2) = 1000/((100/10)/2) = 200
但是，以下加粗的括号 "1000/((100/10)/2)" 是冗余的，
因为他们并不影响操作的优先级，所以你需要返回 "1000/(100/10/2)"。
```

**解析**

纸老虎

**Code**

```java
class Solution {
        public String optimalDivision(int[] nums) {
            int n = nums.length;
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < n; i++) {
                sb.append(nums[i]);
                if (i + 1 < n) sb.append("/");
            }
            if (n > 2) {
                sb.insert(sb.indexOf("/") + 1, "(");
                sb.append(")");
            }
            return sb.toString();
        }
    }
```



## [714]买卖股票的最佳时机含手续费

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。



**示例 1：**

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```



**解析**



**Code**

```java
class Solution {
        public int maxProfit(int[] prices, int fee) {
            int min = prices[0];

            int ans = 0;
            for (int i = 1; i < prices.length; i++) {
                if (prices[i] < min) {
                    min = prices[i];
                }
                if (prices[i] - min - fee > 0) {
                    ans += (prices[i] - min - fee);
                    min = prices[i] - fee;
                }
            }
            return ans;
        }
    }
```

