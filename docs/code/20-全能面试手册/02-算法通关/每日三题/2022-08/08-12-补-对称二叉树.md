## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **139/1000** 。

## [110]平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。



**示例 1：**

![img](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**解析**

首先确定框架是后序遍历，难点在于返回值返回每个节点的高度`return Math.max(left, right) + 1;`。

**Code**

```java
class Solution {
        boolean ans = true;
        public boolean isBalanced(TreeNode root) {
            dfs(root);
            return ans;
        }

        private int dfs(TreeNode root) {
            if (root == null) return 0;
            int left = dfs(root.left);
            int right = dfs(root.right);
            if (Math.abs(left - right) > 1) {
                ans = false;
            }
            return Math.max(left, right) + 1;
        }
    }
```

## [965]单值二叉树

如果二叉树每个节点都具有相同的值，那么该二叉树就是*单值*二叉树。

只有给定的树是单值二叉树时，才返回 `true`；否则返回 `false`。



**示例 1：**

![img](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/screen-shot-2018-12-25-at-50104-pm.png)

```
输入：[1,1,1,1,1,null,1]
输出：true
```



**解析**

直接套dfs模板。

**Code**

```java
    class Solution {
        boolean ans = true;
        List<Integer> list = new ArrayList();
        public boolean isUnivalTree(TreeNode root) {
            if (root == null) return true;

            list.add(root.val);
            dfs(root);
            return ans;
        }

        private void dfs(TreeNode root) {
            if (root == null) return;

            if (!list.contains(root.val)) {
                ans = false;
            }
            dfs(root.left);
            dfs(root.right);

        }
    }
```

## [剑指 Offer 28]对称的二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

`    1    / \   2   2  / \ / \ 3  4 4  3`
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1    / \   2   2    \   \    3    3
```



**示例 1：**

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**解析**

首先一个思路，从左往右遍历和从右往左遍历结果应该是一样的，不过不用试，效率肯定不高。

那如何提高效率？必然是边比较边遍历。

有点像相同子树。

**Code**

```java
class Solution {
        boolean ans = true;

        public boolean isSymmetric(TreeNode root) {
            if (root == null) return true;
            dfs(root.left, root.right);
            return ans;
        }

        private void dfs(TreeNode left, TreeNode right) {
            if (left == null && right == null) {
                return;
            } else if (left == null || right == null) {
                ans = false;
                return;
            } else if (left.val != right.val) {
                ans = false;
            }
            dfs(left.left, right.right);
            dfs(left.right, right.left);
        }
    }
```

