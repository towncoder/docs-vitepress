## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **169/1000** 。

## 今日题型

位运算

## [78]子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。



**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**解析**

二进制表

**Code**

```java
class Solution {
        public List<List<Integer>> subsets(int[] nums) {
            List<List<Integer>> ans = new ArrayList<>();

            for (int i = 0; i < Math.pow(2, nums.length); i++) {
                List<Integer> tmp = new ArrayList<>();
                for (int j = 0; j < nums.length; j++) {
                    // 将二进制位为 1 的加入 List
                    if ((i & (1 << j)) != 0) {
                        tmp.add(nums[j]);
                    }
                }
                ans.add(tmp);
            }
            return ans;
        }
    }
```



## [137]只出现一次的数字 II

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。



**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```



**解析**

二进制位取余。

**Code**

```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3 != 0) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
}
```



## [260]只出现一次的数字 III

给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。



**进阶：**你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？



**示例 1：**

```
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
```

**解析**

异或运算+分治

**Code**

```java
class Solution {
        public int[] singleNumber(int[] nums) {

            int sum = 0;
            for (int j : nums) {
                sum ^= j;
            }
            int lowbit = lowbit(sum);
            int num1 = 0;
            int num2 = 0;
            for (int num : nums) {
                if ((lowbit & num) == 0)
                    num1 ^= num;
                else
                    num2 ^= num;
            }
            return new int[]{num1, num2};
        }

        int lowbit(int n) {
            return n & (-n);
        }
    }
```

