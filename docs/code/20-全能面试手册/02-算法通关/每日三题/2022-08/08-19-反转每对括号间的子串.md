## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **150/1000** 。

## [1190]反转每对括号间的子串

给出一个字符串 `s`（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 **不应** 包含任何括号。



**示例 1：**

```
输入：s = "(abcd)"
输出："dcba"
```



**解析**

- 从前往后遍历字符串，将不是 `)` 的字符串入栈
- 遇到 `)` 时，从队列「尾部」取出字符串，直到遇到 `(` 为止
- 将取出字符串放入队列临时存储，再放入栈，完成翻转
- 循环上述过程，直到原字符串全部出来完成
- 返回栈中的拼接字符串

**Code**

```java
class Solution {
        public String reverseParentheses(String s) {
            StringBuilder ans = new StringBuilder();
            char[] chars = s.toCharArray();
            Stack<Character> stack = new Stack<>();
            Queue<Character> temp = new LinkedList<>();
            for (char aChar : chars) {
                if (aChar == ')') {
                    while (stack.peek() != '(') {
                        Character pop = stack.pop();
                        temp.offer(pop);
                    }
                    stack.pop();
                    while (!temp.isEmpty()) {
                        stack.push(temp.poll());
                    }
                } else {
                    stack.push(aChar);
                }
            }
            stack.forEach(ans::append);
            return ans.toString();
        }
    }
```

## [面试题 02.05]链表求和

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

**示例：**

```
输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
输出：2 -> 1 -> 9，即912
```



**解析**

与栈无关，我觉得算简单题。

**Code**

```java
class Solution {
        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
            ListNode ans = new ListNode(-1);
            ListNode index = ans;
            int t = 0;
            while (l1 != null || l2 != null || t != 0) {
                if (l1 != null) {
                    t += l1.val;
                    l1 = l1.next;
                }
                if (l2 != null) {
                    t += l2.val;
                    l2 = l2.next;
                }

                index.next = new ListNode(t % 10);
                index = index.next;
                t /= 10;
            }
            return ans.next;
        }
    }
```

## [387]字符串中的第一个唯一字符

给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。



**示例 1：**

```
输入: s = "leetcode"
输出: 0
```

**解析**

昏了头了，一直在用队列，明明是哈希表的题。

**Code**

```java
class Solution {
        public int firstUniqChar(String s) {
            Map<Character, Integer> map = new HashMap<Character, Integer>();

            for (int i = 0; i < s.length(); ++i) {
                char ch = s.charAt(i);
                map.put(ch, map.getOrDefault(ch, 0) + 1);
            }
            for (int i = 0; i < s.length(); ++i) {
                if (map.get(s.charAt(i)) == 1) {
                    return i;
                }
            }
            return -1;
        }
    }
```

