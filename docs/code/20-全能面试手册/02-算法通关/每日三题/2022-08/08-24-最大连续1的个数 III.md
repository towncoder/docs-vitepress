## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **169/1000** 。



## [1004]最大连续1的个数 III

给定一个二进制数组 `nums` 和一个整数 `k`，如果可以翻转最多 `k` 个 `0` ，则返回 *数组中连续 `1` 的最大个数* 。



**示例 1：**

```
输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释：[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
```



**解析**



**Code**

```java
class Solution {
        public int longestOnes(int[] nums, int k) {
            // 0 的个数不超过 k 的最长的窗口  —— 滑动窗口
            // 模板
            int left = 0, right = 0;
            int ans = 0;
            int countZero = 0;
            while (right < nums.length) {
                // 需要重新设置窗口的条件 先统计 0  的个数
                if (nums[right] == 0) countZero++;
                if (countZero > k) {
                    // 移除一个 0
                    if (nums[left] == 0) {
                        countZero--;
                    }
                    left++;
                }
                ans = Math.max(ans, right - left + 1);
                right++;
            }

            return ans;
        }
    }
```

## [1208]尽可能使字符串相等

给你两个长度相同的字符串，`s` 和 `t`。

将 `s` 中的第 `i` 个字符变到 `t` 中的第 `i` 个字符需要 `|s[i] - t[i]|` 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。

用于变更字符串的最大预算是 `maxCost`。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

如果你可以将 `s` 的子字符串转化为它在 `t` 中对应的子字符串，则返回可以转化的最大长度。

如果 `s` 中没有子字符串可以转化成 `t` 中对应的子字符串，则返回 `0`。



**示例 1：**

```
输入：s = "abcd", t = "bcdf", maxCost = 3
输出：3
解释：s 中的 "abc" 可以变为 "bcd"。开销为 3，所以最大长度为 3。
```



**解析**



**Code**

```java
class Solution {
        public int equalSubstring(String s, String t, int maxCost) {
            int ans = 0;
            // 其实是求 和 < k 的最长子数组
            // 先构建数组
            int[] data = new int[s.length()];
            for (int i = 0; i < s.length(); i++) {
                data[i] = Math.abs(s.charAt(i) - t.charAt(i));
            }

            // 可以转化的最大长度
            // 通过测试案例确定 是连续子数组，那排序就不行了，只能滑动窗口
            int l = 0, r = 0;
            int sum = 0;
            while (r < data.length) {
                sum += data[r];
                while (sum > maxCost) {
                    sum -= data[l];
                    l++;
                }
                ans = Math.max(ans, r - l + 1);
                r++;
            }
            return ans;
        }
    }
```

## [1876]长度为三且各字符不同的子字符串



如果一个字符串不含有任何重复字符，我们称这个字符串为 **好** 字符串。

给你一个字符串 `s` ，请你返回 `s` 中长度为 **3** 的 **好子字符串** 的数量。

注意，如果相同的好子字符串出现多次，每一次都应该被记入答案之中。

**子字符串** 是一个字符串中连续的字符序列。



**示例 1：**

```
输入：s = "xyzzaz"
输出：1
解释：总共有 4 个长度为 3 的子字符串："xyz"，"yzz"，"zza" 和 "zaz" 。
唯一的长度为 3 的好子字符串是 "xyz" 。
```

**解析**



**Code**

```java
 class Solution {
        public int countGoodSubstrings(String s) {
            // 窗口长度固定为三
            int ans = 0;
            Set<Character> set = new HashSet<Character>();
            int l = 0, r = 0;
            while (r < s.length()) {
                set.add(s.charAt(r));
                if (r - l + 1 > 3) {
                    set.clear();
                    l++;
                    set.add(s.charAt(l));
                    set.add(s.charAt(l+1));
                    set.add(s.charAt(l+2));
                }
                if (set.size() == 3) {
                    ans++;
                }
                r++;
            }
            return ans;
        }
    }
```

