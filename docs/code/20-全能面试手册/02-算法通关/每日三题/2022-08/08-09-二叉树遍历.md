## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **130/1000** 。



## [102]二叉树的层序遍历

**Code**

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root==null)return ans;
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()){
            ArrayList<Integer> level = new ArrayList<>();
            int n = queue.size();
            for (int i = 0; i < n; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);

                if (node.left!=null){
                    queue.offer(node.left);
                }
                if (node.right!=null){
                    queue.offer(node.right);
                }
            }
            ans.add(level);
        }
        return ans;
    }
}
```

## [107]二叉树的层序遍历 II

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）



**示例 1：**

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
```



**解析**

相比于上一题，将从上到下改为从下到上，那直接把上一题的结果倒序一下可以吗？

试了一下，果然是可以的，那我们加一行代码即可：`Collections.reverse(ans);`。

**Code**

```java
List<List<Integer>> ans = new ArrayList<>();
        if (root==null)return ans;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()){
            ArrayList<Integer> level = new ArrayList<>();
            int n = queue.size();
            for (int i = 0; i < n; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);

                if (node.left!=null){
                    queue.offer(node.left);
                }
                if (node.right!=null){
                    queue.offer(node.right);
                }
            }
            ans.add(level);
        }
        Collections.reverse(ans);
        return ans;
```

## [144]二叉树的前序遍历

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。



**示例 1：**

![img](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

**解析**



**Code**

```java
class Solution {
    List<Integer> ans = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root==null)return ans;
        ans.add(root.val);
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        return ans;
    }
}
```

## [145]二叉树的后序遍历

给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。



**示例 1：**

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/pre1.jpg)

```
输入：root = [1,null,2,3]
输出：[3,2,1]
```

**进阶：**递归算法很简单，你可以通过迭代算法完成吗？

**解析**



**Code**

```java
class Solution {
    List<Integer> ans = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root==null)return ans;
        postorderTraversal(root.left);
        postorderTraversal(root.right);
        ans.add(root.val);
        return ans;
    }
}
```

