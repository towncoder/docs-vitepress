## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **105/1000** 。

## [61]旋转链表

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

**示例 1：**

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

**解析**

利用寻找链表的倒数的第K个结点时的双指针法，找到倒数第k个节点和尾节点。把尾节点指向头结点，此时链表成为一个环，再把链表从倒数第k个处断开，即是旋转后的链表。

但是，忽略了一个问题：

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 109`

即 k 是可以大于链表的长度的，那这时候就需要对 k 取模，即假如链表长度是3 ，k = 4 和 k = 1 的结果是一样的。那就先计算长度，再取模。

**Code**

```java
class Solution {
        public ListNode rotateRight(ListNode head, int k) {
            // 特例直接返回
            if (head == null) {
                return head;
            }
            // 通过提示 先计算长度，再取模。简化 k 
            int size = 0;
            ListNode index = head;
            while (index != null) {
                index = index.next;
                size++;
            }
            k = k % size;

            // 这里就是用过的双指针了
            ListNode first = head;
            ListNode last = head;

            for (int i = 0; i < k; i++) {
                last = last.next;
            }
            while (last.next != null) {
                first = first.next;
                last = last.next;
            }

            // 先成环
            last.next = head;
            // 再从 k 处断开
            ListNode ans = first.next;
            first.next = null;
            return ans;
        }
    }
```

## [剑指 Offer 18]删除链表的节点

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

**注意：**此题对比原题有改动

**示例 1:**

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

**解析**

这是一道简单题，思路不难，关键在于怎么把代码实现的够优雅。

正常的思路都是判断当前节点的 val 是否等于目标 val ，这样就造成一个问题，我们好需要一个指针维护前一个结点来做删除操作。

如果我们增加一个虚拟头结点，就可以判断当前结点的下一个的 val 是否等于目标 val ，省去一个指针。

**code**

```java
class Solution {
        public ListNode deleteNode(ListNode head, int val) {
            if (head.val == val) return head.next;

            ListNode dummy = new ListNode(0, head);

            while (head.next != null) {
                if (head.next.val == val) {
                    head.next = head.next.next;
                    break;
                }
                head = head.next;
            }
            return dummy.next;
        }
    }
```

## [剑指 Offer II 023]两个链表的第一个重合节点

给定两个单链表的头节点 `headA` 和 `headB` ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**解析**

这个就是主站的相交链表，做过一次，还是没想起来。

思路不难，就是把两个链表都走一遍，代码实现上需要想一下。

注意，不要修改原链表。

**Code**

```java
public class Solution {
        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            ListNode A = headA;
            ListNode B = headB;
            while (A != B ) {
                if (A == null) {
                    A = headB;
                } else {
                    A = A.next;
                }

                if (B == null) {
                    B = headA;
                } else {
                    B = B.next;
                }
            }
            return A;
        }
    }
```



