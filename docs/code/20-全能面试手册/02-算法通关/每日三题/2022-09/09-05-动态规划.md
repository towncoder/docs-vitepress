## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **195/1000** 。

## 今日题型

动态规划-线性DP

## [264]丑数 II

给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

示例 1：

输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。

**解析**

所有的丑数等于 [1,2,3....,n] * 2/3/5 的集合，关键在于去重和排序，为了节省空间，我们边计算边排序，保证最小的数先去乘。

**Code**

```java
class Solution {
        Map<Integer, Boolean> map = new HashMap();

        public int nthUglyNumber(int n) {
//            return timeOver(n);
            int[] dp = new int[n + 1];
            int p2 = 1, p3 = 1, p5 = 1;
            dp[1] = 1;
            for (int i = 2; i <= n; i++) {
                dp[i] = Math.min(dp[p2] * 2, Math.min(dp[p3] * 3, dp[p5] * 5));
                if (dp[i] == dp[p2] * 2) {
                    p2++;
                }
                if (dp[i] == dp[p3] * 3) {
                    p3++;
                }
                if (dp[i] == dp[p5] * 5) {
                    p5++;
                }
            }
            return dp[n];

        }

        private int timeOver(int n) {
            if (n <= 5) return n;
            int count = 5;
            map.put(1, true);
            map.put(2, true);
            map.put(3, true);
            map.put(4, true);
            map.put(5, true);
            int num = 6;
            while (count < n) {
                if (judge(num, 2) || judge(num, 3) || judge(num, 5)) {
                    count++;
                    map.put(num, true);
                }
                num++;
            }
            return num - 1;
        }

        private boolean judge(int num, int param) {
            return num % param == 0 && map.getOrDefault(num / param, false);
        }
    }
```



## [343]整数拆分

给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

示例 1:

输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

**解析**



**Code**

```java

```



## 



**解析**



**Code**

```java

```

