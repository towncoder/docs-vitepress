## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **195/1000** 。

## 今日题型

[01背包问题](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)

## [416]分割等和子集

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

示例 1：

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

**解析**

转换为 从数据中挑选元素组成字迹，使和等于数组总和的一半

**Code**

```java
    class Solution {
        // 转换为 从数据中挑选元素组成字迹，使和等于数组总和的一半
        public boolean canPartition(int[] nums) {
            int sum = 0;
            for (int num : nums) {
                sum += num;
            }
            if (sum % 2 != 0) {
                return false;
            }

            int halfSum = sum / 2;
            int[] dp = new int[halfSum + 1];

            for (int num : nums) {
                for (int j = halfSum; j >= num; j--) {
                    dp[j] = Math.max(dp[j], dp[j - num] + num);
                }
            }

            return dp[halfSum] == halfSum;
        }
    }
```

## [112]路径总和

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

示例 1：

输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。

**解析**

dfs,回溯

**Code**

```java
class Solution {
        int sum = 0;
        int target = 0;
        boolean ans = false;

        public boolean hasPathSum(TreeNode root, int targetSum) {
            target = targetSum;
            if (root == null) return false;
            dfs(root);
            return ans;
        }

        private void dfs(TreeNode root) {
            if (root == null) {
                return;
            }
            sum = sum + root.val;
            if (root.left == null && root.right == null) {
                if (sum == target) {
                    ans = true;
                }
            }
            dfs(root.left);
            if (root.left != null) {
                sum -= root.left.val;
            }
            dfs(root.right);
            if (root.right != null) {
                sum -= root.right.val;
            }
        }
    }
```



## 



**解析**



**Code**

```java

```

