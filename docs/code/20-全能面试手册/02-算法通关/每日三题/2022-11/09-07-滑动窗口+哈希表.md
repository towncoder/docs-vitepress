## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **169/1000** 。

## 今日题型



## [424]替换后的最长重复字符

给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。

在执行上述操作后，返回包含相同字母的最长子字符串的长度。

示例 1：

输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。

**解析**



**Code**

```java
class Solution {
        public int characterReplacement(String s, int k) {
            if (s.length() == 1) return 1;

            HashMap<Character, Integer> map = new HashMap<>();
            int left = 0;
            int right = 0;
            int max = 0;
            while (right < s.length()) {
                // 记录每个元素出现的次数
                map.put(s.charAt(right), map.getOrDefault(s.charAt(right), 0) + 1);
                // max 计算窗口内出现次数最多的元素
                max = Math.max(max, map.get(s.charAt(right)));
                // 如果需要替换的元素大于 k ，左指针右移，缩小窗口
                if ((right - left - max + 1) > k) {
                    if (max==map.get(s.charAt(left))){
                        max--;
                    }
                    map.put(s.charAt(left), map.get(s.charAt(left)) - 1);
                    left++;
                }
                right++;
            }
            return right - left;
        }
    }
```



## [1493]删掉一个元素以后全为 1 的最长子数组

给你一个二进制数组 nums ，你需要从中删掉一个元素。

请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。

如果不存在这样的子数组，请返回 0 。

提示 1：

输入：nums = [1,1,0,1]
输出：3
解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。
示例 2：

输入：nums = [0,1,1,1,0,1,1,0,1]
输出：5
解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。

**解析**



**Code**

```java
class Solution {
        public int longestSubarray(int[] nums) {
            int left = 0;
            int right = 0;
            int count[] = new int[2];
            while (right < nums.length) {
                count[nums[right]]++;
                if (count[0] > 1) {
                    if (nums[left] == 0) {
                        count[0]--;
                    } else {
                        count[1]--;
                    }
                    left++;
                }
                right++;
            }

            if ((right - left) == 0) return 0;
            return right - left - 1;
        }
    }
```



## 



**解析**



**Code**

```java

```

