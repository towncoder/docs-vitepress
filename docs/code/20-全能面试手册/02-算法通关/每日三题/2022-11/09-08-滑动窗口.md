## 每日三刷，剑指千题

> 计划简介：
>
> - 每日三题，以中等题为主，简单题为辅进行搭配。保证质量题1道，数量题3道。
> - 每日早通勤在LeetCode手机端选题，思考思路，没答案的直接看题解。
> - 每日中午进行编码，时间控制在一小时之内。
> - 下班前半小时进行整理总结，并发布到掘金每日更文活动。
>
> 说明：
>
> - 基于以前的刷题基础，本次计划以中等题为主，大部分中等题都可以拆分为多个简单题，所以数量保证3，质量保证一道中等题即可。
> - 刷题顺序按照先刷链表、二叉树、栈、堆、队列等基本数据结构，再刷递归、二分法、排序、双指针等基础算法，最后是动态规划、贪心、回溯、搜索等复杂算法。
> - 刷题过程中整理相似题型，刷题模板。
> - 目前进度 **213/1000** 。

## 今日题型



## [567]字符串的排列

给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。

换句话说，s1 的排列之一是 s2 的 子串 。

示例 1：

输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").

**解析**



**Code**

```java
class Solution {
        public boolean checkInclusion(String s1, String s2) {
            Map<Character, Integer> map = new HashMap<>();

            Map<Character, Integer> window = new HashMap<>();
            for (int i = 0; i < s1.length(); i++) {
                map.put(s1.charAt(i), map.getOrDefault(s1.charAt(i), 0) + 1);
            }
            int left = 0;
            int right = 0;
            while (right < s2.length()) {
                window.put(s2.charAt(right), window.getOrDefault(s2.charAt(right), 0) + 1);
                if (map.equals(window)) {
                    return true;
                }
                right++;
                if ((right - left + 1) > s1.length()) {
                    if (window.get(s2.charAt(left)) == 1) {
                        window.remove(s2.charAt(left));
                    } else {
                        window.put(s2.charAt(left), window.get(s2.charAt(left)) - 1);
                    }
                    left++;
                }

            }

            return false;
        }
    }
```



## 



**解析**



**Code**

```java

```



## 



**解析**



**Code**

```java

```

