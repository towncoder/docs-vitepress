> 8月1日开始刷题，当时共刷 102 题。
>
> 截止9月7日，应刷 38 * 3 = 108，即总计 210 题，实刷 205 题。
>
> 截止9月20日，应刷 51 * 3 = 153，即总计 255 题，实刷 208 题。
>
> 截止11月8日，重操旧业，实刷 2

史上最简单的算法教程，助力快速通关月薪20k的Java面试。——模板刷题法

## 链表



**简单**



**中等**

### 排序

- [148]排序链表(归并排序)

```java
/**
     * <b>归并排序</b>
     * <p>快慢指针+合并有序链表</p>
     */
    class Solution {
        public ListNode sortList(ListNode head) {
            if (head == null || head.next == null)
                return head;
            // 对于偶数个节点，如果希望慢指针落在中心左边的节点，快指针要比慢指针的起点多一个
            // 如果希望落在中心右边，快慢指针同时开始
            ListNode fast = head.next;
            ListNode slow = head;
            while (fast != null && fast.next != null) {
                fast = fast.next.next;
                slow = slow.next;
            }
            ListNode temp = slow.next;
            slow.next = null;
            ListNode left = sortList(head);
            ListNode right = sortList(temp);
            // 虚拟头节点
            ListNode h = new ListNode(0);
            ListNode res = h;

            while (left != null && right != null) {
                if (left.val < right.val) {
                    h.next = left;
                    left = left.next;
                } else {
                    h.next = right;
                    right = right.next;
                }
                h = h.next;
            }
            // 拼接剩余的多出的节点
            h.next = left != null ? left : right;
            return res.next;
        }
    }
```

- [147]对链表进行插入排序

插入排序 算法的步骤:

插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。

```java
class Solution {
        public ListNode insertionSortList(ListNode head) {
            if (head == null || head.next == null)
                return head;
            ListNode dummyHead = new ListNode(0);
            dummyHead.next = head;

            ListNode index = head.next;
            ListNode sorted = head;
            while (index != null) {
                if (sorted.val <= index.val) {
                    sorted = sorted.next;
                } else {
                    // 遍历已经排好序的元素，找到正确的位置
                    ListNode prev = dummyHead;
                    while (prev.next.val <= index.val) {
                        prev = prev.next;
                    }
                    // 在后面插入元素
                    sorted.next = index.next;
                    index.next = prev.next;
                    prev.next = index;
                }
                index = sorted.next;
            }
            return dummyHead.next;
        }
    }
```



  



## 二叉树



**简单**



**中等**

### 层序遍历

- [116]填充每个节点的下一个右侧节点指针

```java
    class Solution {
        // 二叉树层序遍历
        public Node connect(Node root) {
            if (root == null) return null;
            Queue<Node> queue = new LinkedList<>();
            queue.offer(root);

            while (!queue.isEmpty()) {
                int n = queue.size();
                Node last = null;
                for (int i = 0; i < n; i++) {
                    Node node = queue.poll();
                    if (i > 0) {
                        last.next = node;
                    }
                    last = node;
                    if (node.left != null) {
                        queue.offer(node.left);
                        queue.offer(node.right);
                    }
                }
            }
            return root;
        }
    }
```

- [103]二叉树的锯齿形层序遍历

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20230501022014967.png)

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root==null)return ans;

        Queue<TreeNode> queue=  new LinkedList();
        queue.offer(root);
        int level = 1;
        while (!queue.isEmpty()){
            int size = queue.size();
            List<Integer>  levelValueList = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node!=null){
                    levelValueList.add(node.val);
                    queue.offer(node.left);
                    queue.offer(node.right);
                }
            }
            if (!levelValueList.isEmpty()){
                if (level%2==0){
                    Collections.reverse(levelValueList);
                    ans.add(levelValueList);
                }else {
                    ans.add(levelValueList);
                }
            }
            level++;
        }
        return ans;
    }
}
```





### 通过遍历结果构造二叉树

- [105]从前序与中序遍历序列构造二叉树
- [106]从中序与后序遍历序列构造二叉树

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20230428150348599.png)


**思路**

对于任意一颗树而言，前序遍历的形式总是

```
[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]
```

即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是

```
[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]
```

只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。

这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。

```java
// 105
class Solution {
        private Map<Integer, Integer> indexMap;

        public TreeNode buildTree(int[] preorder, int[] inorder) {
            int n = preorder.length; // 构造哈希映射，帮助我们快速定位根节点
            indexMap = new HashMap<Integer, Integer>();
            for (int i = 0; i < n; i++) {
                indexMap.put(inorder[i], i);
            }
            // 每次递归的应该是传入前序遍历和中序遍历的起始坐标
            return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
        }

        private TreeNode myBuildTree(int[] preorder, int[] inorder,
                                     int preorder_left, int preorder_right,
                                     int inorder_left, int inorder_right) {
            if (preorder_left > preorder_right) {
                return null;
            }

            // 找到根节点，即前序遍历的第一个节点
            int preorder_root = preorder_left;
            // 先把根节点建立出来
            TreeNode root = new TreeNode(preorder[preorder_root]);

            // 找到根节点在中序遍历中的位置
            Integer root_index = indexMap.get(preorder[preorder_root]);
            int length = root_index - inorder_left;
            root.left = myBuildTree(preorder, inorder,
                    preorder_root + 1, preorder_root + length,
                    inorder_left, root_index - 1);
            root.right = myBuildTree(preorder, inorder,
                    preorder_left + length + 1, preorder_right,
                    root_index + 1, inorder_right);
            return root;
        }
    }
```





## 单调栈/队列 



**简单**



**中等**



## 二分查找



**简单**



**中等**



## 前缀和



**简单**



**中等**





## 双指针



**简单**



**中等**





## 滑动窗口

滑动窗口 + 变量计数模板：

```java
class Solution {
    public int slidingWindow(int[] nums, int k) {
        //数组/字符串长度
        int n = nums.length;
        //双指针，表示当前遍历的区间[left, right]，闭区间
        int left = 0, right = 0;
        //定义变量统计 子数组/子区间 是否有效
        int sum = 0;
        //定义变量动态保存最大 求和/计数
        int res = 0;

        //右指针遍历到数组尾
        while (right < n) {
            //增加当前右指针对应的数值
            sum += nums[right];
            //当在该区间内 sum 超出定义范围
            while (sum > k) {
                //先将左指针指向的数值减去
                sum -= nums[left];
                //左指针右移
                left++;
            }
            //到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
            res = Math.max(res, right - left + 1);
            //移动右指针，去探索下一个区间
            right++;
        }
        return res;
    }
}
```



**滑动窗口 + 哈希表存储模板：**

```java
class Solution {
    public String slidingWindow(String s, String t) {
        //创建两个哈希表，分别记录 [需要的] 和 [加入的]
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> map = new HashMap<>();

        //创建 [双指针] 和 [有效数量]
        int left = 0, right = 0;
        int valid = 0;

        //外层循环，供右指针遍历
        while(right < s.length()){
            //创建临时 c 字符，是移入 窗口 内的字符
            char c = s.charAt(right);
            
            //进行窗口一系列逻辑更新
            ...
            
            //判断左指针是否要右移即窗口收缩：有效数量足够满足条件
             /*  可能是规定的窗口大小超出了，可能是有效值数量达成了
             1.  while(valid == need.size())
             2.  while(right - left + 1 >= s1.length())      
             */           
            while(windows need shrink){
                // 创建 d 是要移除窗口的字符
                char d = s.charAt(left);
                left++;

                //进行窗口一系列逻辑更新
                ...
            }
            
            //右指针右移
            right++;
        }
    }
}
```

**简单**

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20221107180225446.png)

**中等**



## 位运算

**位运算的知识**

与&：0&0=0 0&1=0 1&0=0 1&1=1

或|：0|0=0 0|1=1 1|0=1 1|1=1

异或^：0^0=0 0^1=1 1^0=1 1^1=0

取反~：~1=0 ~0=1

左移<<：左边的二进制位丢弃，右边补0

右移>>：正数左补0，负数左补1，右边丢弃

无符号左移<<<：左边的二进制位丢弃，右边补0

无符号右移>>>：忽略符号位，空位都以0补齐



基本原理

0s 表示一串 0，1s 表示一串 1。

x ^ 0s = x      x & 0s = 0      x | 0s = x
x ^ 1s = ~x     x & 1s = x      x | 1s = 1s
x ^ x = 0       x & x = x       x | x = x
利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。

1^1^2 = 2
利用 x & 0s = 0 和 x & 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。

01011011 &
00111100
--------
00011000
利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。

01011011 |
00111100
--------
01111111
位与运算技巧

n&(n-1) 去除 n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。

01011011 &
01011010
--------
01011010
n&(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。

10110100 &
01001100
--------
00000100
n-(n&(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&(n-1) 效果一样。

移位运算

\>\> n 为算术右移，相当于除以 2n，例如 -7 \>\> 2 = -2。

11111111111111111111111111111001  >> 2
--------
11111111111111111111111111111110
\>\>\> n 为无符号右移，左边会补上 0。例如 -7 \>\>\> 2 = 1073741822。

11111111111111111111111111111001  >>> 2
--------
00111111111111111111111111111111
<< n 为算术左移，相当于乘以 2n。-7 << 2 = -28。

11111111111111111111111111111001  << 2
--------
11111111111111111111111111100100
mask 计算

要获取 111111111，将 0 取反即可，~0。

要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1<<(i-1) 。例如 1<<4 得到只有第 5 位为 1 的 mask ：00010000。

要得到 1 到 i 位为 1 的 mask，(1<<i)-1 即可，例如将 (1<<4)-1 = 00010000-1 = 00001111。

要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1<<i)-1)。

Java 中的位操作

html
static int Integer.bitCount();           // 统计 1 的数量
static int Integer.highestOneBit();      // 获得最高位
static String toBinaryString(int i);     // 转换为二进制表示的字符串

> 左移右移我容易搞混。看箭头方向，箭头朝哪边就是向哪边移

**简单**



**中等**





## 贪心算法



**简单**



**中等**



## 动态规划

> 从下五子棋理解动态规划。

**在算法中处于什么位置？**

先有贪心，再有动态规划，再有搜索。（回溯，剪枝，蒙特卡洛树）

**什么是状态转移？**

下一步和上一步什么关系。

**解题思路**

确定dp数组（dp table）以及下标的含义
确定递推公式
dp数组如何初始化
确定遍历顺序
举例推导dp数组

**五大题型**

> 仅讲需要掌握的题型，实际题型更多。

记忆化搜索
### 线性 DP



### 背包 DP

 **0-1 背包问题**

「力扣」第 416 题：分割等和子集（中等）；
「力扣」第 474 题：一和零（中等）；
「力扣」第 494 题：目标和（中等）；
「力扣」第 879 题：盈利计划（困难）；

**完全背包问题**

「力扣」第 322 题：零钱兑换（中等）；
「力扣」第 518 题：零钱兑换 II（中等）；

**简单**



**中等**

### 序列 DP

**简单**

[521]最长特殊序列 Ⅰ

**中等**

[522]最长特殊序列 II

[873]最长的斐波那契子序列的长度

### 区间 DP

状压 DP
状态机 DP
数位 DP
树形 DP

**简单**



**中等**

[139]单词拆分 —— 完全背包

[53/剑指offer 42]最大子序和 —— [经典动态规划](https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)

[55]跳跃游戏Ⅰ/Ⅱ —— 经典dp

416. 分割等和子集 —— 背包DP
474. 一和零 —— 背包DP



## 回溯

**回溯算法与深度优先遍历**

回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

- 找到一个可能存在的正确的答案；
- 在尝试了所有可能的分步方法后宣告该问题没有答案。



**简单**



**中等**

[39]组合总和

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20220920111228680.png)

[40]组合总和 II

## DFS/BFS



**简单**



**中等**



## 字符串



**简单**



**中等**





## 专题

### 子序列问题

![](https://yitiaoit.oss-cn-beijing.aliyuncs.com/img/image-20220908093736313.png)

**简单**



**中等**



## 扩展



**简单**



**中等**



## 



**简单**



**中等**



